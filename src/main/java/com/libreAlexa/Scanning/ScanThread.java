package com.libreAlexa.Scanning;/*  Copyright (C) 2014 Libre Wireless Technology  "Junk Yard Lab" Project*/import android.content.Context;import android.os.Handler;import android.system.ErrnoException;import android.util.Log;import com.cumulations.libreV2.tcp_tunneling.TunnelingClientRunnable;import com.cumulations.libreV2.tcp_tunneling.TunnelingControl;import com.libreAlexa.LibreApplication;import com.libreAlexa.luci.LSSDPNodeDB;import com.libreAlexa.luci.LSSDPNodes;import com.libreAlexa.luci.LUCIControl;import com.libreAlexa.netty.BusProvider;import com.libreAlexa.netty.NettyAndroidClient;import com.libreAlexa.util.LibreLogger;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.InetSocketAddress;import java.net.InterfaceAddress;import java.net.MulticastSocket;import java.net.NetworkInterface;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketException;import java.net.UnknownHostException;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;import java.util.Random;import java.util.Scanner;public class ScanThread implements Runnable {    private static ScanThread instance = new ScanThread();    private ScanThread() {        // Exists only to defeat instantiation.    }    public static ScanThread getInstance() {        if (instance == null) {            instance = new ScanThread();        }        return instance;    }    public void setmContext(Context mContext) {}    private final int MSEARCH_TIMEOUT = 30000;    private Handler mTaskHandler = new Handler();    private boolean mBackgroundMSearchStopped = false;    private Runnable mMyTaskRunnable = new Runnable() {        @Override        public void run() {            LibreLogger.d(TAG, "My task is Sending 1 Minute Once M-Search");            /* do what you need to do */            if (mBackgroundMSearchStopped)                return;            UpdateNodes();            /* and here comes the "trick" */            mTaskHandler.postDelayed(this, MSEARCH_TIMEOUT);        }    };    private ScanningHandler m_ScanningHandler = ScanningHandler.getInstance();    private LSSDPNodeDB lssdpDB = LSSDPNodeDB.getInstance();    private static final String TAG = "ScanThread";    /* public static final String LSSDP_MULTICAST_ADDRESS = "239.255.255.250"; Commenting For HnT Discovery Ip Change*/    private static final String LSSDP_MULTICAST_ADDRESS = "239.255.255.250";    private static final int LSSDP_PORT = 1800;    public static final String ST = "ST";    public static final String LOCATION = "LOCATION";    public static final String NT = "NT";    public static final String NTS = "NTS";    public static final String DEFAULT_ZONEID = "239.255.255.251:3000";    /* Definitions of start line */    public static final String SL_NOTIFY = "NOTIFY * HTTP/1.1";    public static final String SL_MSEARCH = "M-SEARCH * HTTP/1.1";    public static final String SL_OK = "HTTP/1.1 200 OK";    /* Definitions of notification sub type */    public static final String NTS_ALIVE = "ssdp:alive";    public static final String NTS_BYEBYE = "ssdp:byebye";    public static final String NTS_UPDATE = "ssdp:update";    public static final String NTS_BYEBYE_HEADER = "NTS";    public DatagramSocket mDatagramSocketForSendingMSearch;    public MulticastSocket mAliveNotifyListenerSocket;    private NetworkInterface mNetIf = Utils.getActiveNetworkInterface();    public boolean mRunning = true;    private NotifyThread notifyThread = new NotifyThread();    private AliveNotifyThread mAliveNotifyListeningThread = new AliveNotifyThread();    public NettyServerClass nettyServer = new NettyServerClass();    private ServerSocket serverSocket;//        public boolean CreateSocketsForAliveNotifyListener() throws SocketException {//        mNetIf = Utils.getActiveNetworkInterface();//        if (mNetIf == null) {//            LibreLogger.d(TAG, "Network interface is false");//            return false;//        }////        mRunning = true;////        //for sending LSSDP M-Search//        try {//            LibreLogger.d(TAG, "Creating Multicast Socket For Receiving Alive Notify on PORT Number" + LSSDP_PORT);//            String name = mNetIf.getName();//            Utils mUtil = new Utils();////            mAliveNotifyListenerSocket = new MulticastSocket(LSSDP_PORT);//            mAliveNotifyListenerSocket.setLoopbackMode(false);//            mAliveNotifyListenerSocket.setTrafficClass(0x10);//            mAliveNotifyListenerSocket.setReuseAddress(true);//            mAliveNotifyListenerSocket.setSoTimeout(0);//            mAliveNotifyListenerSocket.setNetworkInterface(mNetIf);//            mAliveNotifyListenerSocket.joinGroup//                    (InetAddress.getByName(LSSDP_MULTICAST_ADDRESS));//            LibreLogger.d(TAG, "Creation Of Alive Socket " + "Successfully");////        } catch (IOException e) {//            LibreLogger.d(TAG, "CreationOf Alive Socket " + "failed ");//            e.printStackTrace();//            mRunning = false;//            return false;//        } catch (Exception e) {//            e.printStackTrace();//            LibreLogger.d(TAG, "Exception");//            mRunning = false;//        }//        return true;//    }    public int isLSSDPPortAvailableAndReturnAvailablePort() throws ErrnoException {        ServerSocket socket = null;        Random random = new Random();        int max = 65534;        int min = 10000;        int mRandomPort = random.nextInt(max - min + 1) + min;        while (socket == null) {            try {                socket = new ServerSocket(mRandomPort++);                LibreLogger.d(TAG, "Socket Binded To Port Number" + socket.getLocalPort());            } catch (SocketException e) {                e.printStackTrace();                LibreLogger.d(TAG, "Socket Exception in scan thread: " + e);            } catch (IOException e) {                e.printStackTrace();                LibreLogger.d(TAG, "Socket Failed Binded To Port Number" + (mRandomPort - 1));            }catch (Exception e) {                e.printStackTrace();            }            if (socket != null) {                try {                    socket.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return socket.getLocalPort();    }    private DatagramPacket getBroadcastPacket(String MSearchPayload, NetworkInterface mNetI) throws UnknownHostException {        List<InterfaceAddress> list = mNetI.getInterfaceAddresses();        for (InterfaceAddress ia : list) {            LibreLogger.d(TAG, "Broadcast address is " + ia.getBroadcast());            if (ia.getBroadcast() == null) {                continue;            }            return new DatagramPacket(MSearchPayload.getBytes(),                    MSearchPayload.length(), ia.getBroadcast(), LSSDP_PORT);        }        return null;    }    public void closeMSearchThread() {        if (mTaskHandler != null) {            mTaskHandler.removeCallbacksAndMessages(null);        }    }    private boolean CreateSockets() throws SocketException {        boolean mTcpStartedListening;        mNetIf = Utils.getActiveNetworkInterface();        boolean isNetIfNull = mNetIf == null;        LibreLogger.d(TAG, "Network interface null "+isNetIfNull);        if (mNetIf == null) {            return false;        }        //for sending LSSDP M-Search        try {            LibreApplication.mLuciThreadInitiated = true;            LibreLogger.d(TAG, "Creating Multicast Socket For Sending M-Search");            Utils mUtil = new Utils();            /* This is the Random port Number Value For  Sending & Receiving M-Search and Response             * Default Value = -1 */            int mPortToSendMSearchAndGetResponse = isLSSDPPortAvailableAndReturnAvailablePort();            LibreApplication.mTcpPortInUse = mPortToSendMSearchAndGetResponse;            mDatagramSocketForSendingMSearch = new DatagramSocket(new InetSocketAddress(mUtil.getIPAddress(true), mPortToSendMSearchAndGetResponse));            mDatagramSocketForSendingMSearch.setTrafficClass(0x10);            mDatagramSocketForSendingMSearch.setReuseAddress(true);            /*mDatagramSocketForSendingMSearch.joinGroup(new InetSocketAddrfess                            (LSSDP_MULTICAST_ADDRESS, LSSDP_PORT),                    NetworkInterface.getByName(name));*/            LibreLogger.d(TAG, "Creation of Socket Success On the Random Port Number : " + mPortToSendMSearchAndGetResponse);            /*  KK ., We have to Discover the Device Whenever a TCP Server Creation Got Failed Too , So We have to Start the UDP Unicast Thread before it , So I have made this Change*/            try {                if (mDatagramSocketForSendingMSearch != null && !notifyThread.isAlive()) {                    LibreLogger.d(TAG, "Notify Thread Started Listening on the Port Number  " + mPortToSendMSearchAndGetResponse);                    notifyThread.start();                    LibreLogger.d(TAG, "Notify Thread State" + notifyThread.getState());                }            } catch (Exception e) {                e.printStackTrace();            }            mTcpStartedListening = nettyServer.startServer(mPortToSendMSearchAndGetResponse);            LibreLogger.d(TAG, "TCP Started Listening Success/Fail  " + mTcpStartedListening);             if(LibreApplication.isWifiON) {                 LibreLogger.d(TAG, "Task is Creating For Sending M-Search " + MSEARCH_TIMEOUT);                 mTaskHandler.postDelayed(mMyTaskRunnable, MSEARCH_TIMEOUT);             }        } catch (Exception e) {            e.printStackTrace();            mDatagramSocketForSendingMSearch = null;            LibreLogger.d(TAG, "Creation of Sockets" + "Failure");            return false;        }        return true;    }    public synchronized void close() {        try {            instance = null;            LibreApplication.mLuciThreadInitiated = false;            mRunning = false;            mBackgroundMSearchStopped = true;            if (mDatagramSocketForSendingMSearch != null) {                if (!mDatagramSocketForSendingMSearch.isClosed())                    mDatagramSocketForSendingMSearch.close();            }            if (serverSocket != null) {                if (!serverSocket.isClosed())                    serverSocket.close();            }            if (mAliveNotifyListenerSocket != null) {                if (!mAliveNotifyListenerSocket.isClosed()) {                    mAliveNotifyListenerSocket.close();                }            }            mAliveNotifyListenerSocket = null;            mDatagramSocketForSendingMSearch = null;        } catch (IOException e) {            e.printStackTrace();        }    }    private void RemovingTheCorrespondingSceneMapFromCentralDB(LSSDPNodes mNode) {        String mIpAddress = mNode.getIP();        LSSDPNodeDB mNodeDB = LSSDPNodeDB.getInstance();        try {            if (ScanningHandler.getInstance().isIpAvailableInCentralSceneRepo(mIpAddress)) {                boolean status = ScanningHandler.getInstance().removeSceneMapFromCentralRepo(mIpAddress);                LibreLogger.d(TAG, "Removing the Corresponding SceneMap Fro CentralDB status is " + status + " For the ip is " + mIpAddress);            }        } catch (Exception e) {            LibreLogger.d(TAG, "Removing the Corresponding SceneMap Fro CentralDB status" + "Removal Exception ");        }        mNodeDB.clearNode(mIpAddress);    }    private void createOrUpdateTunnelingClients(final LSSDPNodes mInputNode) {        /* It will not Wait for Socket to be created */        try {            if (TunnelingControl.isTunnelingClientPresent(mInputNode.getIP())) {                Socket mExistingSocket = TunnelingControl.getTunnelingClient(mInputNode.getIP());                LibreLogger.d(TAG, "createOrUpdateTunnelingClients, socket ip " + mInputNode.getIP() + " is connected " + mExistingSocket.isConnected());                /*Socket is Already Exists*/                if (!mExistingSocket.isConnected()) {                    mExistingSocket.close();                    TunnelingControl.removeTunnelingClient(mInputNode.getIP());                    new Thread(new TunnelingClientRunnable(mInputNode.getIP())).start();                }            } else {                new Thread(new TunnelingClientRunnable(mInputNode.getIP())).start();            }        } catch (Exception e) {            e.printStackTrace();            LibreLogger.d(TAG, "createOrUpdateTunnelingClients, exception = " + e.getMessage());        }    }    private void CreateOrUpdateMyNewDevice_NoFn_Dependency(final LSSDPNodes mInputNode) {        LibreLogger.d(TAG,"update new device wihtout FN  ScanThread before luciSocket Map \n"+LUCIControl.luciSocketMap.toString()+"sucess cert\n");        if (!LUCIControl.luciSocketMap.isEmpty()&&LUCIControl.luciSocketMap.containsKey(mInputNode.getIP())) {            NettyAndroidClient nettyAndroidClient = LUCIControl.luciSocketMap.get(mInputNode.getIP());            nettyAndroidClient.setLastNotifiedTime(System.currentTimeMillis());        }        else{            LibreLogger.d(TAG,"update new device wihtout FN ScanThread else  \n"+LUCIControl.luciSocketMap.toString()+"actual node\n"+mInputNode);            /* I will remove previous Socket Information */          //  RemovingTheCorrespondingSceneMapFromCentralDB(mInputNode);            LibreLogger.d("CREATE_DEVICE","@@@First Notification  ScanThread else case \n"+LibreApplication.securecertExchangeSucessDevices.get("cert"));            NettyAndroidClient nettyAndroidClient = null;            try {                nettyAndroidClient = new NettyAndroidClient(mInputNode.getNodeAddress(), 7777,true);                if(LibreApplication.securecertExchangeSucessDevices.get("cert").contains(mInputNode.getIP())){                   LUCIControl.luciSocketMap.put(mInputNode.getIP(), nettyAndroidClient);                    LibreLogger.d(TAG,"android developer luci socket map TWO adding \n"+LUCIControl.luciSocketMap.toString());                    new LUCIControl(mInputNode.getIP()).sendAsynchronousCommandSpecificPlaces();                    LibreApplication.fnFlowPassed.put("firstNotify",mInputNode.getIP());                    LibreLogger.d(TAG,"addToNodeDb inside ScanThread ifCase NettyAndroidClient\n"+mInputNode.getIP());                    LSSDPNodeDB lssdpNodeDB = LSSDPNodeDB.getInstance();                    LSSDPNodes theNodeBasedOnTheIpAddress = lssdpNodeDB.getTheNodeBasedOnTheIpAddress(mInputNode.getIP());                    if (theNodeBasedOnTheIpAddress != null && theNodeBasedOnTheIpAddress.getgCastVerision() != null) {                        // sleep                        try {                            Thread.sleep(150);                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                    if (mInputNode.getIP() != null /*&& mInputNode.getDeviceState() != null*/ && !m_ScanningHandler.findDupicateNode(mInputNode)) {                        LibreLogger.d(TAG, "New Node is Found For the ipAddress " + mInputNode.getIP());                        boolean isFilteredSpeaker = LSSDPNodeDB.getInstance().hasFilteredModels(mInputNode);                        LibreLogger.d(TAG,"addToNodeDb, "+mInputNode.getFriendlyname()+" isFilteredSpeaker = "+isFilteredSpeaker);                        if (!mInputNode.getUSN().isEmpty()/*&&LibreApplication.nettyActiveWriteDevices.get("active")!=null&&LibreApplication.nettyActiveWriteDevices.get("active").equals(mInputNode.getIP()) /*&& isFilteredSpeaker*/) {                            BusProvider.getInstance().post(mInputNode);                            m_ScanningHandler.lssdpNodeDB.addToNodeDb(mInputNode);                            LibreLogger.d(TAG,"addToNodeDb inside ScanThread addedSucessfully, "+mInputNode.getIP());                        } else {                            LibreLogger.d(TAG, "USN is Empty " + mInputNode.getIP());                        }                       // createOrUpdateTunnelingClients(mInputNode);                }                }            } catch (Exception e) {                e.printStackTrace();            }        }    }    public void run() {        try {            /* Creation of Socket is ALready Done when we are creating the Class and Starting the Thread For Listening on 1800*/            if (mAliveNotifyListenerSocket != null && !mAliveNotifyListeningThread.isAlive() &&                    mAliveNotifyListeningThread.getState() == Thread.State.NEW) {                LibreLogger.d(TAG, "mAliveNotifyListener Socket Starting on the port Number " + "1800 ");                try {                    mAliveNotifyListeningThread.start();                } catch (IllegalThreadStateException e1) {                    e1.printStackTrace();                    LibreLogger.d(TAG, "mAliveNotifyListener Socket Starting on the port Number " + "1800 Got Exception ");                }            }            /* Creation of Socket , And Start Listening of UDP Unicast & TCP Unicast on the RandomPort Number*/            if (!CreateSockets()) {                return;            }        } catch (SocketException e) {            LibreLogger.d(TAG, "Create Sockets " + " Got Failed !! ");            e.printStackTrace();            return;        } catch (Exception e) {            LibreLogger.d(TAG, "Socket Creation Failed " + " No Discovery ");            e.printStackTrace();            return;        }        LibreLogger.d(TAG, "Scan thread Started  " + " Successfully !! ");    }    public synchronized void shutdown() {        Log.v(TAG, "Scan Thread Shutdown");        mRunning = false;    }    private DatagramPacket receiveAliveNotifyMultiCastForPortNumber1800() throws IOException {        byte[] buf = new byte[1024];        DatagramPacket dp = new DatagramPacket(buf, buf.length);        LibreLogger.d(TAG, "receiveAliveNotifyMultiCastForPortNumber1800" + "Trying To receieve Notify");        /*if(mFirmwareUpgradeListenerSocket==null){            LibreLogger.d(TAG,"ReceiveMulticast" + "mMulticastSocketAlive Notify is Null");            CreateSocketsForFirmwareUpgradeListener();        }*/        //  mDatagramSocketForSendingMSearch.receive(dp);        mAliveNotifyListenerSocket.receive(dp);        LibreLogger.d(TAG, "receiveAliveNotifyMultiCastForPortNumber1800" + "Received Notify: From " + dp.getAddress() + "Of Length" + dp.getLength());        return dp;    }    private DatagramPacket receiveMSearchMultiCast() throws IOException {        byte[] buf = new byte[1024];        DatagramPacket dp = new DatagramPacket(buf, buf.length);        LibreLogger.d(TAG, "receiveMSearchMultiCast" + "Trying To receieve Notify");        mDatagramSocketForSendingMSearch.receive(dp);        LibreLogger.d(TAG, "receiveMSearchMultiCast" + "Received Notify: From " + dp.getAddress() + "Of Length" + dp.getLength());        return dp;    }    private String parseHeaderValue(String content, String headerName) {        Scanner s = new Scanner(content);        s.nextLine(); // Skip the start line        while (s.hasNextLine()) {            String line = s.nextLine();            if (line.equals(""))                return null;            int index = line.indexOf(':');            if (index == -1)                return null;            String header = line.substring(0, index);            if (headerName.equalsIgnoreCase(header.trim())) {                return line.substring(index + 1).trim();            }        }        return null;    }    private String parseHeaderValue(DatagramPacket dp, String headerName) {        return parseHeaderValue(new String(dp.getData()), headerName);    }    private String parseStartLine(String content) {        Scanner s = new Scanner(content);        return s.nextLine();    }    private String parseStartLine(DatagramPacket dp) {        return parseStartLine(new String(dp.getData()));    }    public boolean clearNodes() {        lssdpDB.clearDB();        m_ScanningHandler.clearSceneObjectsFromCentralRepo();        LUCIControl.luciSocketMap.clear();        LibreApplication.securecertExchangeSucessDevices.clear();        lssdpDB.GetDB().clear();        //mRunning = false;        return false;    }    public synchronized boolean UpdateNodes() {        if (mNetIf == null)            return false;        new Thread() {            public void run() {                final NetworkInterface mNetI = Utils.getActiveNetworkInterface();                if (mNetI == null)                    return;                String MSearchPayload = "M-SEARCH * HTTP/1.1\r\n" +                        "MX: 10\r\n" +                        "ST: urn:schemas-upnp-org:device:DDMSServer:1\r\n" +                        "HOST: 239.255.255.250:1800\r\n" +                        "MAN: \"ssdp:discover\"\r\n" +                        "\r\n";                LibreLogger.d(TAG, "Sending M-Search");                DatagramPacket mSearchDatagramPacket = null;                DatagramPacket mSearchBroadcast = null;                try {                    mSearchDatagramPacket = new DatagramPacket(MSearchPayload.getBytes(),                            MSearchPayload.length(), InetAddress.getByName(LSSDP_MULTICAST_ADDRESS), LSSDP_PORT);                } catch (Exception e) {                    LibreLogger.d(TAG,"updateNodes mSearchDatagramPacket create exception "+e.getMessage());                    e.printStackTrace();                }                try {                    mSearchBroadcast = getBroadcastPacket(MSearchPayload,mNetI);                } catch (Exception e) {                    LibreLogger.d(TAG,"updateNodes mSearchBroadcast create exception "+e.getMessage());                    e.printStackTrace();                }                try {                    if (mDatagramSocketForSendingMSearch == null) {                        LibreLogger.d(TAG, "Sending M-Search " + "mDatagramSocketForSendingMSearch is Null");                    } else {                        mDatagramSocketForSendingMSearch.send(mSearchDatagramPacket);                        mDatagramSocketForSendingMSearch.send(mSearchBroadcast);                        LibreLogger.d(TAG, "Sending M-Search " + "Successful");                    }                } catch (Exception e) {                    e.printStackTrace();                    LibreLogger.d(TAG, "Sending M-Search UnSuccessful "+e.getMessage());                }            }        }.start();        return true;    }    public class AliveNotifyThread extends Thread {        @Override        public void interrupt() {            LibreLogger.d(TAG, "Notify Thread Interrupted");            super.interrupt();        }        @Override        public void run() {            LibreLogger.d(TAG,"AliveNotifyThread run");            LookForAliveNotify();        }    }    private void LookForNotify() {        DatagramPacket dp;        while (mRunning) {            try {                dp = receiveMSearchMultiCast();                String startLine = parseStartLine(dp);                LibreLogger.d(TAG, "receiveMSearchMultiCast" + "Received Notify: From " + dp.getAddress().getHostAddress() + " with StartLine " + startLine);                LibreLogger.d(TAG, "TcpSocketMap Contains" + LUCIControl.luciSocketMap.keySet().toString());                try {                    if (startLine.equals(SL_NOTIFY) || startLine.equals(SL_OK)) {                        String mSearchMessageReceivedFromResponse = new String(dp.getData());                        LibreLogger.d(TAG, "receiveMSearchMultiCast test " + "Received Notify: From " + dp.getAddress().getHostAddress() + " with message " + mSearchMessageReceivedFromResponse);                        LSSDPNodes mNodeToBeUpdateOrAdded = m_ScanningHandler.getLSSDPNodeFromMessage(dp.getSocketAddress(), mSearchMessageReceivedFromResponse);                        if (mNodeToBeUpdateOrAdded != null) { /*LatestDiscoveryChanges        OLD LUCI Architecture till 2022: * Which means we are getting notification for first time hence we should remove old one and recreate it*/        /*New Architecture changes  as per 20 NOV 2023 release : we are not depending on FN=1  notification only ,        below method removes dependency on FN =1 OR FN=0 here on adding only when secure cert exchanges sucessfully for secure devices        and nonsecure devices when cert variable is false */                            CreateOrUpdateMyNewDevice_NoFn_Dependency(mNodeToBeUpdateOrAdded);                            LibreLogger.d(TAG,"createorUpdatedevice one\n"+mNodeToBeUpdateOrAdded.getIP());                        }                    }                } catch (Exception e) {                    e.printStackTrace();                    LibreLogger.d(TAG,"LookForNotify, exception = "+e.getMessage());                }            } catch (Exception e) {                e.printStackTrace();                LibreLogger.d(TAG,"LookForNotify, exception = "+e.getMessage());            }        }    }    private void LookForAliveNotify() {        DatagramPacket dp;        while (mRunning) {            try {                dp = receiveAliveNotifyMultiCastForPortNumber1800();                String startLine = parseStartLine(dp);                LibreLogger.d(TAG, "receiveAliveNotifyMultiCast" + "Received Notify: From " + dp.getAddress().getHostAddress() + " with StartLine " + startLine);                LibreLogger.d(TAG, "TcpSocketMap Contains" + LUCIControl.luciSocketMap.keySet().toString());                try {                    if (startLine.equals(SL_NOTIFY) || startLine.equals(SL_OK)) {                        String mSearchMessageReceivedFromResponse = new String(dp.getData());                        LibreLogger.d(TAG, "receiveAliveNotifyMultiCast test " + "Received Notify: From " + dp.getAddress().getHostAddress() + " with message " + mSearchMessageReceivedFromResponse);                        LSSDPNodes mNodeToBeUpdateOrAdded = m_ScanningHandler.getLSSDPNodeFromMessage(dp.getSocketAddress(), mSearchMessageReceivedFromResponse);                        if (mNodeToBeUpdateOrAdded != null) {                             /*LatestDiscoveryChanges        OLD LUCI Architecture till 2022: * Which means we are getting notification for first time hence we should remove old one and recreate it*/        /*New Architecture changes  as per 20 NOV 2023 release : we are not depending on FN=1  notification only ,        below method removes dependency on FN =1 OR FN=0 here on adding only when secure cert exchanges sucessfully for secure devices        and nonsecure devices when cert variable is false */                            CreateOrUpdateMyNewDevice_NoFn_Dependency(mNodeToBeUpdateOrAdded);                            LibreLogger.d(TAG,"createorUpdatedevice two\n"+mNodeToBeUpdateOrAdded.getIP());                        }                        }                } catch (Exception e) {                    e.printStackTrace();                    LibreLogger.d(TAG,"LookForAliveNotify, exception = "+e.getMessage());                    clearNodes();                    LibreApplication.securecertExchangeSucessDevices.clear();                }            } catch (Exception e) {                e.printStackTrace();                clearNodes();                LibreApplication.securecertExchangeSucessDevices.clear();                LibreLogger.d(TAG,"LookForAliveNotify, exception = "+e.getMessage());      }        }    }    public class NotifyThread extends Thread {        @Override        public void interrupt() {            LibreLogger.d(TAG, "Notify Thread Interrupted");            super.interrupt();        }        @Override        public void run() {            LibreLogger.d(TAG,"NotifyThread run");            LookForNotify();        }    }}