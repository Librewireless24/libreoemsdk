package com.libreAlexa.Scanning;import android.util.Log;import com.cumulations.libreV2.tcp_tunneling.TunnelingClientRunnable;import com.cumulations.libreV2.tcp_tunneling.TunnelingControl;import com.libreAlexa.LibreApplication;import com.libreAlexa.luci.LSSDPNodeDB;import com.libreAlexa.luci.LSSDPNodes;import com.libreAlexa.luci.LUCIControl;import com.libreAlexa.netty.BusProvider;import com.libreAlexa.netty.NettyAndroidClient;import com.libreAlexa.netty.NettyClientHandler;import com.libreAlexa.util.LibreLogger;import java.net.InetAddress;import java.net.InetSocketAddress;import java.net.Socket;import java.util.Objects;import org.jboss.netty.buffer.ChannelBuffer;import org.jboss.netty.channel.ChannelHandlerContext;import org.jboss.netty.channel.ChannelStateEvent;import org.jboss.netty.channel.ChildChannelStateEvent;import org.jboss.netty.channel.ExceptionEvent;import org.jboss.netty.channel.MessageEvent;import org.jboss.netty.channel.SimpleChannelHandler;public class EchoServerHandler extends SimpleChannelHandler {    public ScanningHandler m_scanHandler = ScanningHandler.getInstance();    public NettyClientHandler handler;    public static String TAG=EchoServerHandler.class.getSimpleName();    @Override    public void childChannelClosed(ChannelHandlerContext ctx, ChildChannelStateEvent e) throws Exception {        super.childChannelClosed(ctx, e);    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)            throws Exception {        //super.exceptionCaught(ctx, e);        System.out.println(" EXCEPTION CaUGHT ++ " + e.getCause().toString());        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LibreLogger.d(TAG, "Exception  Caught For the Ip " + address.getHostAddress() + "as" + e.getCause().getMessage());        if (LUCIControl.channelHandlerContextMap.containsKey(address.getHostAddress())) {            if (isChannelToBeRemovedFromTheChannelHandlerMap(ctx, address.getHostAddress())) {                LUCIControl.channelHandlerContextMap.get(address.getHostAddress()).getChannel().close();                LUCIControl.channelHandlerContextMap.remove(address.getHostAddress());            }        }    }    @Override    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.channelConnected(ctx, e);        InetAddress address = null;        if (e.getChannel().getRemoteAddress() instanceof InetSocketAddress) {            LibreLogger.d(TAG,"LSSDP socket connected successfully");            address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();            LibreLogger.d(TAG, "Channel Connected For the Ip " + address.getHostAddress()                    +                    "for the Channel id is " + ctx.getChannel().getId());            ctx.getChannel().getConfig().setOption("child.keepAlive", true);            ctx.getChannel().getConfig().setOption("child.reuseaddress", true);            ctx.getChannel().getConfig().setOption("child.tcpNoDelay", true);            ctx.getChannel().getConfig().setOption("child.tcpNoDelay", true);            handler = new NettyClientHandler(address.getHostAddress());        } else {            LibreLogger.d(TAG,"LSSDP socket NOT connected successfully");        }    }    @Override    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.channelDisconnected(ctx, e);        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LibreLogger.d(TAG, "Channel Disconnected For the Ip " + address.getHostAddress()                + "for the Channel id is " + e.getChannel().getId());        if (LUCIControl.channelHandlerContextMap.containsKey(address.getHostAddress())) {            if (isChannelToBeRemovedFromTheChannelHandlerMap(ctx, address.getHostAddress())) {                LUCIControl.channelHandlerContextMap.get(address.getHostAddress()).getChannel().close();                LUCIControl.channelHandlerContextMap.remove(address.getHostAddress());            }        }    }    @Override    public void closeRequested(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.closeRequested(ctx, e);    }    @Override    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.channelClosed(ctx, e);        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LibreLogger.d(TAG, "Channel Closed For the Ip " + address.getHostAddress()                + "for the Channel id is " + e.getChannel().getId());        if (LUCIControl.channelHandlerContextMap.containsKey(address.getHostAddress())) {            if (isChannelToBeRemovedFromTheChannelHandlerMap(ctx, address.getHostAddress())) {                LUCIControl.channelHandlerContextMap.get(address.getHostAddress()).getChannel().close();                LUCIControl.channelHandlerContextMap.remove(address.getHostAddress());            }        }    }    @Override    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)            throws Exception {        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LUCIControl.channelHandlerContextMap.put("" + address.getHostAddress(), ctx);        ChannelBuffer mChannelBufferMessageReceived = (ChannelBuffer) e.getMessage();        String mSearchMessageReceivedFromResponse = new String(mChannelBufferMessageReceived.array());        LibreLogger.d(TAG, "M Search messageReceived from ip = " + e.getRemoteAddress()                +"\t, Message = " + mSearchMessageReceivedFromResponse);        /* We have to Store Only NOTIFY HandlerContext */        if (mSearchMessageReceivedFromResponse.contains("NOTIFY")) {            LibreLogger.d(TAG, "M Search messageReceived, Notify updating for ip " + address.getHostAddress()                    + ", Channel id " + ctx.getChannel().getId());            ctx.getChannel().getConfig().setOption("child.keepAlive", true);            ctx.getChannel().getConfig().setOption("child.reuseaddress", true);            ctx.getChannel().getConfig().setOption("child.tcpNoDelay", true);            LUCIControl.channelHandlerContextMap.put(address.getHostAddress(), ctx);        }        LSSDPNodes node = m_scanHandler.getLSSDPNodeFromMessage(e.getRemoteAddress(), mSearchMessageReceivedFromResponse);        if (node == null)            return;        /*LatestDiscoveryChanges        OLD LUCI Architecture till 2022: * Which means we are getting notification for first time hence we should remove old one and recreate it*/        /*New Architecture changes  as per 20 NOV 2023 release : we are not depending on FN=1  notification only ,        below method removes dependency on FN =1 OR FN=0 here on adding only when secure cert exchanges sucessfully for secure devices        and nonsecure devices when cert variable is false */        CreateOrUpdateMyNewDevice_NoFn_Dependency(node);        LibreLogger.d(TAG,"createorUpdatedevice three\n"+node.getIP());        createOrUpdateTunnelingClients(node);    }    private void CreateOrUpdateMyNewDevice_NoFn_Dependency(final LSSDPNodes mInputNode) {        LibreLogger.d(TAG,"update new device wihtout FN  EchoServer before luciSocket Map \n"+LUCIControl.luciSocketMap.toString());            if (!LUCIControl.luciSocketMap.isEmpty()&&LUCIControl.luciSocketMap.containsKey(mInputNode.getIP())) {                NettyAndroidClient nettyAndroidClient = LUCIControl.luciSocketMap.get(mInputNode.getIP());                nettyAndroidClient.setLastNotifiedTime(System.currentTimeMillis());            }            else{                LibreLogger.d(TAG,"update new device with FN echoserver else  \n"+LUCIControl.luciSocketMap.toString()+"actual node\n"+mInputNode.getIP());                LibreLogger.d("CREATE_DEVICE","@@@First Notification  EchoServer else case \n"+LibreApplication.securecertExchangeSucessDevices.get("cert"));                    NettyAndroidClient nettyAndroidClient = null;                try {                    nettyAndroidClient = new NettyAndroidClient(mInputNode.getNodeAddress(), 7777,true);                    if(LibreApplication.securecertExchangeSucessDevices.get("cert")!=null &&LibreApplication.securecertExchangeSucessDevices.get("cert").contains(mInputNode.getIP())){                        LUCIControl.luciSocketMap.put(mInputNode.getIP(), nettyAndroidClient);                        LibreLogger.d(TAG,"android developer luci socket map ONE adding \n"+LUCIControl.luciSocketMap.toString());                        new LUCIControl(mInputNode.getIP()).sendAsynchronousCommandSpecificPlaces();                        LibreApplication.fnFlowPassed.put("firstNotify",mInputNode.getIP());                        LibreLogger.d(TAG,"addToNodeDb inside ScanThread ifCase NettyAndroidClient\n"+mInputNode.getIP());                        LibreLogger.d("CREATE_DEVICE","@@@First Notification if case \n"+LibreApplication.fnFlowPassed.get("firstNotify"));                        LSSDPNodeDB lssdpNodeDB = LSSDPNodeDB.getInstance();                        LSSDPNodes theNodeBasedOnTheIpAddress = lssdpNodeDB.getTheNodeBasedOnTheIpAddress(mInputNode.getIP());                        if (theNodeBasedOnTheIpAddress != null && theNodeBasedOnTheIpAddress.getgCastVerision() != null) {                            // sleep                            try {                                Thread.sleep(250);                            } catch (InterruptedException e) {                                e.printStackTrace();                            }                        }                        if (mInputNode.getIP() != null&& !m_scanHandler.findDupicateNode(mInputNode)) {                            LibreLogger.d(TAG, "New Node is Found For the ipAddress get luci device " + LUCIControl.luciSocketMap.toString());                            boolean isFilteredSpeaker = LSSDPNodeDB.getInstance().hasFilteredModels(mInputNode);                            LibreLogger.d(TAG,"addToNodeDb, "+mInputNode.getFriendlyname()+" isFilteredSpeaker = "+isFilteredSpeaker);                            if (!mInputNode.getUSN().isEmpty()/*&& isFilteredSpeaker*/) {                                BusProvider.getInstance().post(mInputNode);                                m_scanHandler.lssdpNodeDB.addToNodeDb(mInputNode);                                LibreLogger.d(TAG,"addToNodeDb inside ScanThread addedSucessfully, "+mInputNode.getIP());                            } else {                                LibreLogger.d(TAG, "USN is Empty " + mInputNode.getIP());                            }                    }                    }                } catch (Exception e) {                    e.printStackTrace();                }            }    }    private boolean isChannelToBeRemovedFromTheChannelHandlerMap(ChannelHandlerContext ctx, String mIpAddress) {        if (ctx.getChannel().getId().equals(LUCIControl.channelHandlerContextMap.get(mIpAddress).getChannel().getId())) {            LibreLogger.d(TAG, "EchoServerHandler" + "Channel is broken " + mIpAddress + "id as "                    + ctx.getChannel().getId() + "but its  Matched with " +                    LUCIControl.channelHandlerContextMap.get(mIpAddress).getChannel().getId()            );            return true;        } else {            LibreLogger.d(TAG, "EchoServerHandler" + "Channel is broken " + mIpAddress + "id as "                    + ctx.getChannel().getId() + "but its Not Matched with " +                    LUCIControl.channelHandlerContextMap.get(mIpAddress).getChannel().getId()            );            return false;        }    }    private void RemovingTheCorrespondingSceneMapFromCentralDB(LSSDPNodes mNode) {        String mIpAddress = mNode.getIP();        LSSDPNodeDB mNodeDB = LSSDPNodeDB.getInstance();        try {            if (ScanningHandler.getInstance().isIpAvailableInCentralSceneRepo(mIpAddress)) {                boolean status = ScanningHandler.getInstance().removeSceneMapFromCentralRepo(mIpAddress);                LibreLogger.d(TAG, "Removing the Corresponding SceneMap Fro CentralDB status is " + status + " For the ip is " + mIpAddress);            }        } catch (Exception e) {            LibreLogger.d(TAG, "Removing the Corresponding SceneMap Fro CentralDB status" + "Removal Exception ");        }        mNodeDB.clearNode(mIpAddress);    }    private void createOrUpdateTunnelingClients(final LSSDPNodes mInputNode) {        /* It will not Wait for Socket to be created */        try {            if (TunnelingControl.isTunnelingClientPresent(mInputNode.getIP())) {                Socket mExistingSocket = TunnelingControl.getTunnelingClient(mInputNode.getIP());                LibreLogger.d(TAG, "createOrUpdateTunnelingClients, socket ip " + mInputNode.getIP() + " is connected " + mExistingSocket.isConnected());                /*Socket is Already Exists*/                if (!mExistingSocket.isConnected()) {                    mExistingSocket.close();                    TunnelingControl.removeTunnelingClient(mInputNode.getIP());                    new Thread(new TunnelingClientRunnable(mInputNode.getIP())).start();                }            } else {                new Thread(new TunnelingClientRunnable(mInputNode.getIP())).start();            }        } catch (Exception e) {            e.printStackTrace();            LibreLogger.d(TAG, "createOrUpdateTunnelingClients, exception = " + e.getMessage());        }    }}